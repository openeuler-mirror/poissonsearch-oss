[[docs-update-by-query]]
== Update By Query API

experimental[The update-by-query API is new and should still be considered experimental.  The API may change in ways that are not backwards compatible]

The simplest usage of `updateByQuery` updates each
document in an index without changing the source. This usage enables
<<picking-up-a-new-property,picking up a new property>> or another online
mapping change.

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source("source_index").abortOnVersionConflict(false);

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

Calls to the `updateByQuery` API start by getting a snapshot of the index, indexing
any documents found using the `internal` versioning.

NOTE: Version conflicts happen when a document changes between the time of the
snapshot and the time the index request processes.

When the versions match, `updateByQuery` updates the document
and increments the version number.

All update and query failures cause `updateByQuery` to abort. These failures are
available from the `BulkIndexByScrollResponse#getIndexingFailures` method. Any
successful updates remain and are not rolled back. While the first failure
causes the abort, the response contains all of the failures generated by the
failed bulk request.

To prevent version conflicts from causing `updateByQuery` to abort, set
`abortOnVersionConflict(false)`. The first example does this because it is
trying to pick up an online mapping change and a version conflict means that
the conflicting document was updated between the start of the `updateByQuery`
and the time when it attempted to update the document. This is fine because
that update will have picked up the online mapping update.

Back to the API, `UpdateByQueryRequestBuilder` supports filtering the documents
that are updated, limiting the total number updated, and updating documents
with a script:

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source("source_index")
        .filter(termQuery("level", "awesome"))
        .size(1000)
        .script(new Script("ctx._source.awesome = 'absolutely'", ScriptType.INLINE, "painless", emptyMap()));

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

`UpdateByQueryRequestBuilder` also allows you direct access to the query used
to select the documents which you can use to change the default scroll size or
otherwise modify the request for matching documents.

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source("source_index")
        .source().setSize(500);

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

You can also combine `size` with sorting to limit the documents updated:

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source("source_index").size(100)
        .source().addSort("cat", SortOrder.DESC);

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

In addition to changing the `_source` of the document (see above) the script
can change the update action similarly to the Update API:

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source("source_index")
        .script(new Script(
            "if (ctx._source.awesome == 'absolutely) {"
          + "  ctx.op='noop'
          + "} else if (ctx._source.awesome == 'lame') {"
          + "  ctx.op='delete'"
          + "} else {"
          + "ctx._source.awesome = 'absolutely'}", ScriptType.INLINE, "painless", emptyMap()));

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

Just as in <<docs-update,Update API>> you can set `ctx.op` to change the
operation that is executed:

`noop`::

Set `ctx.op = "noop"` if your script decides that it doesn't have to make any
changes. That will cause `updateByQuery` to omit that document from its updates.
 This no operation will be reported in the `noop` counter in the
<<docs-update-by-query-response-body, response body>>.

`delete`::

Set `ctx.op = "delete"` if your script decides that the document must be
deleted. The deletion will be reported in the `deleted` counter in the
<<docs-update-by-query-response-body, response body>>.

Setting `ctx.op` to anything else is an error. Setting any
other field in `ctx` is an error.

This API doesn't allow you to move the documents it touches, just modify their
source. This is intentional! We've made no provisions for removing the document
from its original location.

It's also possible to do this whole thing on multiple indexes and multiple
types at once, just like the search API:

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source("foo", "bar").source().setTypes("a", "b");

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

If you provide `routing` then the routing is copied to the scroll query,
limiting the process to the shards that match that routing value:

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.source().setRouting("cat");

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

`updateByQuery` can also use the <<ingest>> feature by
specifying a `pipeline` like this:

[source,java]
--------------------------------------------------
UpdateByQueryRequestBuilder updateByQuery = UpdateByQueryAction.INSTANCE.newRequestBuilder(client);

updateByQuery.setPipeline("hurray");

BulkIndexByScrollResponse response = updateByQuery.get();
--------------------------------------------------

[float]
[[docs-update-by-query-task-api]]
=== Works with the Task API

You can fetch the status of all running update-by-query requests with the
<<tasks,Task API>>:

[source,java]
--------------------------------------------------
ListTasksResponse tasksList = client.admin().cluster().prepareListTasks()
        .setActions(UpdateByQueryAction.NAME).setDetailed(true).get();

for (TaskInfo info: tasksList.getTasks()) {
    TaskId taskId = info.getTaskId();
    BulkByScrollTask.Status status = (BulkByScrollTask.Status) info.getStatus();
    // do stuff
}

--------------------------------------------------

With the `TaskId` shown above you can look up the task directly:

// provide API Example
[source,java]
--------------------------------------------------
GetTaskResponse get = client.admin().cluster().prepareGetTask(taskId).get();
--------------------------------------------------

[float]
[[docs-update-by-query-cancel-task-api]]
=== Works with the Cancel Task API

Any Update By Query can be canceled using the <<tasks,Task Cancel API>>:

[source,java]
--------------------------------------------------
// Cancel all update-by-query requests
client.admin().cluster().prepareCancelTasks().setActions(UpdateByQueryAction.NAME).get().getTasks()
// Cancel a specific update-by-query request
client.admin().cluster().prepareCancelTasks().setTaskId(taskId).get().getTasks()
--------------------------------------------------

The `taskId` can be found using the list tasks API above.

Cancelation should happen quickly but might take a few seconds. The task status
API above will continue to list the task until it is wakes to cancel itself.


[float]
[[docs-update-by-query-rethrottle]]
=== Rethrottling

The value of `requests_per_second` can be changed on a running update by query
using the `_rethrottle` API:

[source,java]
--------------------------------------------------
RethrottleAction.INSTANCE.newRequestBuilder(client).setTaskId(taskId).setRequestsPerSecond(2.0f).get();
--------------------------------------------------

The `taskId` can be found using the tasks API above.

Just like when setting it on the `updateByQuery` API `requests_per_second`
can be either `Float.POSITIVE_INFINITY` to disable throttling or any positive
float to throttle to that level. Rethrottling that speeds up the query takes
effect immediately but rethrotting that slows down the query will take effect
on after completing the current batch. This prevents scroll timeouts.
