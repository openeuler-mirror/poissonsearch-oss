---
setup:
  - do:
      cluster.health:
        wait_for_status: yellow

---
teardown:
  - do:
      xpack.watcher.delete_watch:
        id: "cluster_health_watch"
        ignore: 404

---
"Getting started - Monitor cluster health":
  - do:
      xpack.watcher.stats: {}
  - match: { "stats.0.watcher_state": "started" }
  - match: { "stats.0.watch_count": 0 }

  # extract http host and port from master node
  - do:
      cluster.state: {}
  - set: { master_node: master }

  - do:
      nodes.info:
        metric: [ http ]
  - is_true: nodes.$master.http.publish_address
  - set: { nodes.$master.http.publish_address: host }

  - do:
      ingest.simulate:
        body:
          pipeline:
            description: _description
            processors: [ grok: { field: host, patterns : ["%{IPORHOST:hostname}:%{NUMBER:port:int}"]} ]
          docs: [ { _index: index, _type: type, _id: id, _source: { host: $host } } ]
  - set: { docs.0.doc._source.hostname: hostname }
  - set: { docs.0.doc._source.port: port }

  - do:
      xpack.watcher.put_watch:
        id: "cluster_health_watch"
        body:
          trigger:
            schedule:
              interval: 1s
          input:
            http:
              request:
                host: $hostname
                port: $port
                path: "/_cluster/health"
                auth:
                  basic:
                    username: test_admin
                    password: changeme
          condition:
            compare:
              "ctx.payload.number_of_data_nodes":
                lt: 10
          actions:
            log:
              logging:
                text: "executed at {{ctx.execution_time}}"

  - match: { _id: "cluster_health_watch" }
  - match: { created: true }

  - do:
      indices.refresh:
        index: .watches

  - do:
      xpack.watcher.stats: {}
  - match: { "stats.0.watch_count": 1 }

  # Simulate a Thread.sleep()
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "cluster_health_watch"
                      }
                    }
                  },
                  {
                    "term": {
                       "result.condition.met": {
                         "value": "true"
                       }
                    }
                  }
                ]
              }
            }
          }
  - gte:  { hits.total: 1 }

  - do:
      xpack.watcher.delete_watch:
        id: "cluster_health_watch"
  - match: { found: true }

  - do:
      indices.refresh:
        index: .watches

  - do:
      xpack.watcher.stats: {}
  - match: { "stats.0.watch_count": 0 }
