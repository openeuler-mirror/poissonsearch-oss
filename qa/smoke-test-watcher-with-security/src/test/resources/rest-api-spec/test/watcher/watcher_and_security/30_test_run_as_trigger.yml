---
setup:
  - do:
      cluster.health:
          wait_for_status: yellow

  # user watcher_user is allowed to write into this index
  - do:
      index:
        index: my_test_index
        type: type
        id: 1
        refresh: true
        body: >
          {
            "value" : "15"
          }

---
teardown:
  - do:
      xpack.watcher.delete_watch:
        id: "my_watch"
        ignore: 404




---
"Test watch search input is run as user who added the watch":
  - do:
      xpack.watcher.put_watch:
        id: "my_watch"
        body:  >
          {
            "throttle_period" : "1h",
            "trigger": {
              "schedule" : { "interval" : "3s" }
            },
            "input": {
              "search" : {
                "request" : {
                  "indices" : [ "my_test_index" ],
                  "body" :{
                    "query" : { "match_all": {} }
                  }
                }
              }
            },
            "condition" : {
              "compare" : {
                "ctx.payload.hits.total" : {
                  "gte" : 1
                }
              }
            },
            "actions": {
              "logging": {
                "logging": {
                  "text": "Successfully ran my_watch to test for search input"
                }
              }
            }
          }
  - match: { _id: "my_watch" }

  # Simulate sleeping, so that the watch triggers
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "my_watch"
                      }
                    }
                  },
                  {
                    "term": {
                      "result.condition.met": {
                        "value": "true"
                      }
                    }
                  }
                ]
              }
            },
            "sort": [
              {
                "trigger_event.triggered_time": {
                  "order": "desc"
                  }
              }
              ]
          }
  - gte:  { hits.total: 1 }
  - match: { hits.hits.0._source.watch_id: "my_watch" }
  - match: { hits.hits.0._source.state: "executed" }




---
"Test watch search input does not work against index user is not allowed to read":

  - do:
      # by impersonating this request as powerless user we cannot query the my_test_index
      # headers: { es-security-runas-user: powerless_user }
      xpack.watcher.put_watch:
        id: "my_watch"
        body:  >
          {
            "trigger": {
              "schedule" : { "interval" : "3s" }
            },
            "input": {
              "search" : {
                "request" : {
                  "indices" : [ "index_not_allowed_to_read" ],
                  "body" :{
                    "query" : { "match_all": {} }
                  }
                }
              }
            },
            "condition" : {
              "compare" : {
                "ctx.payload.hits.total" : {
                  "gte" : 1
                }
              }
            },
            "actions": {
              "logging": {
                "logging": {
                  "text": "This message should never occur in the logs as the search above should have failed"
                }
              }
            }
          }
  - match: { _id: "my_watch" }

  # Simulate sleeping, so that the watch triggers
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "my_watch"
                      }
                    }
                  }
                ]
              }
            },
            "sort": [
              {
                "trigger_event.triggered_time": {
                  "order": "desc"
                  }
              }
              ]
          }
  - gte:  { hits.total: 1 }
  - match: { hits.hits.0._source.watch_id: "my_watch" }
  - match: { hits.hits.0._source.state: "execution_not_needed" }


---
"Test watch search transform is run as user who added the watch":
  - do:
      xpack.watcher.put_watch:
        id: "my_watch"
        body:  >
          {
            "trigger": {
              "schedule" : { "interval" : "3s" }
            },
            "input": {
              "simple" : {
                "foo" : "bar"
              }
            },
            "transform" : {
              "search" : {
                "request" : {
                  "indices" : [ "my_test_index" ],
                  "body" :{
                    "query" : { "match_all": {} }
                  }
                }
              }
            },
            "actions": {
              "index": {
                "index": {
                  "index" : "my_test_index",
                  "doc_type" : "type",
                  "doc_id": "my-id"
                }
              }
            }
          }
  - match: { _id: "my_watch" }

  # Simulate sleeping, so that the watch triggers
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "my_watch"
                      }
                    }
                  },
                  {
                    "term": {
                       "result.condition.met": {
                         "value": "true"
                       }
                    }
                  }
                ]
              }
            },
            "sort": [
              {
                "trigger_event.triggered_time": {
                  "order": "desc"
                  }
              }
              ]
          }
  - gte:  { hits.total: 1 }
  - match: { hits.hits.0._source.watch_id: "my_watch" }

  - do:
      get:
        index: my_test_index
        type: type
        id: my-id
  # this value is from the document in the my_text_index index, see the setup
  - match: { _source.hits.hits.0._source.value: "15" }


---
"Test watch search transform does not work without permissions":
  - skip:
      version:     "all"
      reason:      "AwaitsFix on https://github.com/elastic/x-pack-elasticsearch/issues/3753"
  - do:
      xpack.watcher.put_watch:
        id: "my_watch"
        body:  >
          {
            "trigger": {
              "schedule" : { "interval" : "3s" }
            },
            "input": {
              "simple" : {
                "foo" : "bar"
              }
            },
            "transform" : {
              "search" : {
                "request" : {
                  "indices" : [ "index_not_allowed_to_read" ],
                  "body" :{
                    "query" : { "match_all": {} }
                  }
                }
              }
            },
            "actions": {
              "index": {
                "index": {
                  "index" : "my_test_index",
                  "doc_type" : "type",
                  "doc_id": "my-id"
                }
              }
            }
          }
  - match: { _id: "my_watch" }

  # Simulate sleeping, so that the watch triggers
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "my_watch"
                      }
                    }
                  },
                  {
                    "term": {
                       "result.condition.met": {
                         "value": "true"
                       }
                    }
                  }
                ]
              }
            },
            "sort": [
              {
                "trigger_event.triggered_time": {
                  "order": "desc"
                  }
              }
              ]
          }
  - gte:  { hits.total: 1 }
  - match: { hits.hits.0._source.watch_id: "my_watch" }

  - do:
      get:
        index: my_test_index
        type: type
        id: my-id
  - match: { _source.hits.total: 0 }



---
"Test watch index action requires permission to write to an index":
  - do:
      xpack.watcher.put_watch:
        id: "my_watch"
        body:  >
          {
            "trigger": {
              "schedule" : { "interval" : "3s" }
            },
            "input": {
              "simple" : {
                "foo" : "bar"
              }
            },
            "actions": {
              "index": {
                "index": {
                  "index" : "my_test_index",
                  "doc_type" : "type",
                  "doc_id": "my-id"
                }
              }
            }
          }
  - match: { _id: "my_watch" }

  # Simulate sleeping, so that the watch triggers
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "my_watch"
                      }
                    }
                  },
                  {
                    "term": {
                       "result.condition.met": {
                         "value": "true"
                       }
                    }
                  }
                ]
              }
            },
            "sort": [
              {
                "trigger_event.triggered_time": {
                  "order": "desc"
                  }
              }
              ]
          }
  - gte:  { hits.total: 1 }
  - match: { hits.hits.0._source.watch_id: "my_watch" }
  - match: { hits.hits.0._source.state: "executed" }

  - do:
      get:
        index: my_test_index
        type: type
        id: 1
  - match: { _id: "1" }



---
# this is tricky to test, as we are not allowed to read the index...
"Test watch index action does not work without permissions":
  - do:
      xpack.watcher.put_watch:
        id: "my_watch"
        body:  >
          {
            "trigger": {
              "schedule" : { "interval" : "3s" }
            },
            "input": {
              "simple" : {
                "foo" : "bar"
              }
            },
            "actions": {
              "index": {
                "index": {
                  "index" : "index_not_allowed_to_read",
                  "doc_type" : "type",
                  "doc_id": "my-id"
                }
              }
            }
          }
  - match: { _id: "my_watch" }

  # Simulate sleeping, so that the watch triggers
  - do:
      catch: request_timeout
      cluster.health:
        wait_for_nodes: 99
        timeout: 5s
  - match: { "timed_out": true }

  - do:
      indices.refresh:
        index: .watcher-history-*

  - do:
      search:
        index: .watcher-history-*
        body: >
          {
            "query": {
              "bool": {
                "must" : [
                  {
                    "term": {
                      "watch_id": {
                        "value": "my_watch"
                      }
                    }
                  },
                  {
                    "term": {
                       "result.condition.met": {
                         "value": "true"
                       }
                    }
                  }
                ]
              }
            },
            "sort": [
              {
                "trigger_event.triggered_time": {
                  "order": "desc"
                  }
              }
              ]
          }
  - gte:  { hits.total: 1 }
  - match: { hits.hits.0._source.watch_id: "my_watch" }
  - match: { hits.hits.0._source.state: "executed" }

  - do:
      get:
        index: index_not_allowed_to_read
        type: type
        id: 1
      catch: forbidden

