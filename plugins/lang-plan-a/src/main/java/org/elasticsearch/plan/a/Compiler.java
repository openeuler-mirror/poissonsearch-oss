/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.plan.a;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.elasticsearch.bootstrap.BootstrapInfo;

import java.net.MalformedURLException;
import java.net.URL;
import java.security.CodeSource;
import java.security.SecureClassLoader;
import java.security.cert.Certificate;

/**
 * The Compiler is the entry point for generating a Plan A script.  The compiler will generate an ANTLR
 * parse tree based on the source code that is passed in.  Two passes will then be run over the parse tree,
 * one for analysis using the {@link Analyzer} and another to generate the actual byte code using ASM in
 * the {@link Writer}.
 */
final class Compiler {
    /**
     * The default language API to be used with Plan A.  The second construction is used
     * to finalize all the variables, so there is no mistake of modification afterwards.
     */
    private static Definition DEFAULT_DEFINITION = new Definition(new Definition());

    /**
     * Define the class with lowest privileges.
     */
    private static final CodeSource CODESOURCE;

    /**
     * Setup the code privileges.
     */
    static {
        try {
            // Setup the code privileges.
            CODESOURCE = new CodeSource(new URL("file:" + BootstrapInfo.UNTRUSTED_CODEBASE), (Certificate[]) null);
        } catch (MalformedURLException impossible) {
            throw new RuntimeException(impossible);
        }
    }

    /**
     * A secure class loader used to define Plan A scripts.
     */
    static class Loader extends SecureClassLoader {
        /**
         * @param parent The parent ClassLoader.
         */
        Loader(final ClassLoader parent) {
            super(parent);
        }

        /**
         * Generates a Class object from the generated byte code.
         * @param name The name of the class.
         * @param bytes The generated byte code.
         * @return A Class object extending {@link Executable}.
         */
        Class<? extends Executable> define(final String name, final byte[] bytes) {
            return defineClass(name, bytes, 0, bytes.length, CODESOURCE).asSubclass(Executable.class);
        }
    }

    /**
     * Runs the two-pass compiler to generate a Plan A script.
     * @param loader The ClassLoader used to define the script.
     * @param name The name of the script.
     * @param source The source code for the script.
     * @param settings The CompilerSettings to be used during the compilation.
     * @return An {@link Executable} Plan A script.
     */
    static Executable compile(final Loader loader, final String name, final String source,
                              final Definition custom, final CompilerSettings settings) {
        final Definition definition = custom != null ? new Definition(custom) : DEFAULT_DEFINITION;
        final ParserRuleContext root = createParseTree(source, definition);
        final Metadata metadata = new Metadata(definition, source, root, settings);
        Analyzer.analyze(metadata);
        final byte[] bytes = Writer.write(metadata);
        final Executable executable = createExecutable(loader, definition, name, source, bytes);

        return executable;
    }

    /**
     * Generates the ANTLR tree from the given source code.  Several methods below, are used
     * to ensure that the first error generated by ANTLR will cause the compilation to fail rather than
     * use ANTLR's recovery strategies that may be potentially dangerous.
     * @param source The source code for the script.
     * @param definition The Plan A API.
     * @return The root node for the ANTLR parse tree.
     */
    private static ParserRuleContext createParseTree(final String source, final Definition definition) {
        final ANTLRInputStream stream = new ANTLRInputStream(source);
        final ErrorHandlingLexer lexer = new ErrorHandlingLexer(stream);
        final PlanAParser parser = new PlanAParser(new CommonTokenStream(lexer));
        final ParserErrorStrategy strategy = new ParserErrorStrategy();

        lexer.removeErrorListeners();
        lexer.setTypes(definition.structs.keySet());
        parser.removeErrorListeners();
        parser.setErrorHandler(strategy);

        ParserRuleContext root = parser.source();

        return root;
    }

    /**
     * Generates an {@link Executable} that can run a Plan A script.
     * @param loader The {@link Loader} to define the script's class file.
     * @param definition The Plan A API.
     * @param name The name of the script.
     * @param source The source text of the script.
     * @param bytes The ASM generated byte code to define the class with.
     * @return A Plan A {@link Executable} script.
     */
    private static Executable createExecutable(final Loader loader, final Definition definition,
                                               final String name, final String source, final byte[] bytes) {
        try {
            // Used for debugging.  Uncomment this code and add -Dtests.security.manager=false when running to save
            // the generated Java class files.  The javap tool can then be used to inspect the generated byte code.

            // try {
            //    FileOutputStream f = new FileOutputStream(new File("<path>"), false);
            //    f.write(bytes);
            //    f.close();
            // } catch (Exception e) {
            //    throw new RuntimeException(e);
            // }

            final Class<? extends Executable> clazz = loader.define(Writer.CLASS_NAME, bytes);
            final java.lang.reflect.Constructor<? extends Executable> constructor =
                    clazz.getConstructor(Definition.class, String.class, String.class);

            return constructor.newInstance(definition, name, source);
        } catch (final Exception exception) { // Catch everything to let the user know this is something caused internally.
            throw new IllegalStateException(
                    "An internal error occurred attempting to define the script [" + name + "].", exception);
        }
    }

    /**
     * All methods in the compiler should be static.
     */
    private Compiler() {}
}
